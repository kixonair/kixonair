<!doctype html>
<html lang="en">
<head>
  <script>
    (function () {
      // Permit local development hosts in addition to the production domains.
      var ok = ['kixonair.com', 'www.kixonair.com', '', 'localhost', '127.0.0.1'];
      try {
        if (!ok.includes(location.hostname)) location.replace('https://kixonair.com');
      } catch (e) {}
    })();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0f14" />
  <title>Kixonair — Match Center</title>
  <link rel="stylesheet" href="/styles.css?v=34" />
  <link rel="icon" href="/logo.svg" type="image/svg+xml" />
  <style>
    /*
     * Premium match centre styling
     *
     * The original layout has been preserved but colours, spacing,
     * typography and components are upgraded for a more upscale look.
     */
    :root{
      /* base spacing */
      --pad: clamp(12px, 3vw, 22px);
      /* colour palette */
      --primary-bg: #0f172a;        /* darkest panel background */
      --secondary-bg: #1e293b;      /* card background */
      --border-col: #334155;        /* soft border colour */
      --accent: #6366f1;            /* violet accent for buttons */
      --accent-hover: #7c3aed;      /* deeper violet for hover */
      --text-col: #f1f5f9;          /* near white for text */
      --muted-col: #94a3b8;         /* muted grey for secondary text */
      --success-col: #10b981;       /* green for loading indicator */
    }

    /* global resets and typography */
    html, body{
      margin:0; padding:0;
      background: radial-gradient(circle at top left, var(--primary-bg), var(--secondary-bg));
      color: var(--text-col);
      font-family: 'Segoe UI', Tahoma, sans-serif;
      line-height: 1.5;
    }

    a{ color: inherit; }

    .wrap{
      max-width:980px;
      margin:0 auto;
      padding:var(--pad);
    }

    /* header bar */
    .headerbar{
      display:grid;
      grid-template-columns:auto 1fr auto;
      align-items:center;
      margin-bottom:16px;
      color: var(--text-col);
    }
    .headerbar .center{justify-self:center;}

    /* competition badge */
    .badge{
      display:inline-block;
      border:1px solid var(--border-col);
      background: var(--secondary-bg);
      color: var(--text-col);
      border-radius:999px;
      padding:4px 12px;
      font-size:12px;
      max-width:50vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* teams grid */
    .teams{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      gap:18px;
      align-items:center;
      justify-items:center;
      margin:20px 0 8px;
      background: var(--secondary-bg);
      border:1px solid var(--border-col);
      border-radius:16px;
      padding:16px;
      box-shadow:0 4px 8px rgba(0,0,0,0.3);
    }
    .side{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      text-align:center;
    }
    .side img{
      width:clamp(64px,14vw,96px);
      height:clamp(64px,14vw,96px);
      object-fit:contain;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    }
    .teamName{
      font-size:clamp(18px,4.5vw,24px);
      font-weight:600;
      line-height:1.3;
      color: var(--text-col);
      /* Allow long team names to wrap on small screens instead of truncating.
         Removing the truncation styles lets the browser break names onto multiple lines
         so they remain readable on phone‑sized viewports. */
      white-space: normal;
      overflow-wrap: anywhere;
      max-width:100%;
    }
    .h1{
      font-size:clamp(28px,8vw,42px);
      font-weight:800;
      text-align:center;
      letter-spacing:.08em;
      color: var(--accent);
    }
    .muted{
      color: var(--muted-col);
    }
    .statusBig{
      margin-top:8px;
      margin-bottom:6px;
      text-align:center;
      font-size:18px;
      font-weight:500;
      color: var(--accent);
    }

    /* meta information grid */
    .meta{
      display:grid;
      grid-template-columns:repeat(3,minmax(0,1fr));
      gap:12px;
      margin:20px 0;
      background: var(--secondary-bg);
      border:1px solid var(--border-col);
      border-radius:16px;
      padding:16px;
      box-shadow:0 4px 8px rgba(0,0,0,0.3);
    }
    @media(max-width:720px){ .meta{grid-template-columns:repeat(2,minmax(0,1fr));} }

    /* server bar */
    .serverbar{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      justify-content:center;
      margin:18px 0 4px;
      background: var(--secondary-bg);
      border:1px solid var(--border-col);
      border-radius:16px;
      padding:16px;
      box-shadow:0 4px 8px rgba(0,0,0,0.3);
    }
    .serverbar .sbtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:120px;
      border-radius:12px;
      padding:12px 18px;
      text-decoration:none;
      color:var(--text-col);
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
      transition: background 0.3s ease, transform 0.1s ease;
      font-weight:500;
    }
    .serverbar .sbtn:hover{
      background: linear-gradient(135deg, var(--accent-hover) 0%, var(--accent) 100%);
      transform: translateY(-2px);
    }

    /* loading overlay */
    .loading{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:rgba(5,12,23,0.8);
      backdrop-filter:saturate(120%) blur(4px);
      z-index:50;
      transition:opacity .25s ease;
    }
    .loading.hidden{ opacity:0; pointer-events:none; }
    .spinner{
      position:relative;
      width:74px;
      height:74px;
      margin-bottom:10px;
    }
    .ring{
      position:absolute;
      inset:0;
      border-radius:50%;
      border:4px solid rgba(255,255,255,.1);
      border-top-color: var(--accent);
      animation:spin 1s linear infinite;
    }
    .dot{
      position:absolute;
      top:50%; left:50%;
      width:16px; height:16px;
      background: var(--success-col);
      border-radius:50%;
      transform:translate(-50%,-50%);
      animation:pulse 1.4s ease-in-out infinite;
    }
    .loadingText{
      font-size:14px;
      color: var(--muted-col);
      letter-spacing:.02em;
    }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    @keyframes pulse{ 0%,100%{ transform:translate(-50%,-50%) scale(.85); opacity:.85 } 50%{ transform:translate(-50%,-50%) scale(1.1); opacity:1 } }

    /* hide league badge on small screens */
    @media(max-width:600px){ #leagueBadge{ display:none; } }

    /* back button styling */
    .btn{
      display:inline-block;
      padding:8px 14px;
      border:1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      border-radius:8px;
      text-decoration:none;
      font-weight:500;
      transition: background 0.25s ease, color 0.25s ease;
    }
    .btn:hover{
      background: var(--accent);
      color:#ffffff;
    }

    /* header */
    header.header{
      background: var(--secondary-bg);
      border-bottom:1px solid var(--border-col);
    }
    header .bar{
      max-width:980px;
      margin:0 auto;
      padding: var(--pad);
      display:flex;
      align-items:center;
    }
  </style>
</head>
<body>
<header class="header">
  <div class="bar">
    <a class="brand" href="/"><img src="/logo.svg" alt="Kixonair" height="28"/></a>
    <div style="flex:1"></div>
  </div>
</header>

<main class="wrap">
  <div id="loadingOverlay" class="loading" aria-live="polite" aria-busy="true">
    <div class="spinner"><div class="ring"></div><div class="dot"></div></div>
    <div class="loadingText">Loading match…</div>
  </div>

  <div class="headerbar">
    <a class="btn" href="/" aria-label="Back to schedule">← Back</a>
    <div class="center"></div>
    <span id="leagueBadge" class="badge"></span>
  </div>

  <div class="teams">
    <div class="side home"><img id="homeLogo" alt="" width="64" height="64" loading="lazy"/><span class="teamName" id="homeName"></span></div>
    <div class="h1" id="versus">VS</div>
    <div class="side away"><img id="awayLogo" alt="" width="64" height="64" loading="lazy"/><span class="teamName" id="awayName"></span></div>
  </div>
  <div class="muted statusBig" id="statusLine" style="text-align:center"></div>

  <div class="meta">
    <div><span class="muted small">Kickoff</span><div id="kickoff">-</div></div>
    <div><span class="muted small">Competition</span><div id="league">-</div></div>
    <div><span class="muted small">Status</span><div id="state">-</div></div>
  </div>

  <div id="serverBar" class="serverbar"></div>
</main>

<script>
  // ======== CONFIG ========
  const API_KEY = 'kix-7d29f2d9ef3c4';
  const API_BASE = './api';

  function apiFetch(url, init = {}) {
    const u = new URL(url, location.href);
    u.searchParams.set('api_key', API_KEY);
    const headers = Object.assign({}, init.headers || {}, {
      'API_key': API_KEY,
      'api_key': API_KEY,
      'X-API-Key': API_KEY
    });
    return fetch(u.toString(), Object.assign({ credentials: 'include' }, init, { headers }));
  }

  // ======== helpers ========
  let __loadFailTimer = null;
  const $ = id => document.getElementById(id);
  function hideLoading(){ try{ $('loadingOverlay').classList.add('hidden'); }catch{} if(__loadFailTimer){clearTimeout(__loadFailTimer);__loadFailTimer=null;} }
  function qs(name){ return new URLSearchParams(location.search).get(name) || ''; }
  function slug(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }
  function capWords(s){ return String(s||'').split(/[-\\s]+/).map(w => w? w[0].toUpperCase()+w.slice(1):'').join(' '); }
  function ymdFromIso(x){ try{ return String(x||'').slice(0,10) || null; }catch{return null;} }
  function addDays(dateStr, delta){ const dt = new Date(Date.UTC(+dateStr.slice(0,4), +dateStr.slice(5,7)-1, +dateStr.slice(8,10))); dt.setUTCDate(dt.getUTCDate()+delta); return dt.toISOString().slice(0,10); }

  /**
   * Map various status codes coming from the fixture API into human friendly labels.
   * The API can return statuses such as "IN_PLAY", "PAUSED", "SCHEDULED", "FINISHED",
   * "HALF-TIME" etc. We normalise them to four distinct states:
   *  - Scheduled: the match has not started yet
   *  - Live: the match is currently in progress (1st or 2nd half)
   *  - Half Time: the match is in its half‑time break
   *  - Finished: the match has concluded
   * If none of the above patterns are detected the original status string is returned.
   */
  function formatStatus(status){
    const raw = String(status || '').toUpperCase();
    // patterns representing a live match
    const livePatterns = ['IN_PLAY','LIVE','PLAYING','1ST HALF','FIRST HALF','2ND HALF','SECOND HALF'];
    for (const p of livePatterns){ if (raw.includes(p)) return 'Live'; }
    // patterns representing half time
    const halfPatterns = ['HALF-TIME','HALFTIME','HT','HALF TIME','PAUSED'];
    for (const p of halfPatterns){ if (raw.includes(p)) return 'Half Time'; }
    // patterns representing finished matches
    const finPatterns = ['FINISHED','FULL-TIME','FT','FINAL','ENDED'];
    for (const p of finPatterns){ if (raw.includes(p)) return 'Finished'; }
    // scheduled / not started
    const schedPatterns = ['SCHEDULED','NOT_STARTED','NS'];
    for (const p of schedPatterns){ if (raw.includes(p)) return 'Scheduled'; }
    return status || '';
  }

  /**
   * Map various status codes coming from the fixture API into human friendly labels.
   * The API can return statuses such as "IN_PLAY", "PAUSED", "SCHEDULED", "FINISHED",
   * "HALF-TIME" etc. We normalise them to four distinct states:
   *  - Scheduled: the match has not started yet
   *  - Live: the match is currently in progress (1st or 2nd half)
   *  - Half Time: the match is in its half‑time break
   *  - Finished: the match has concluded
   * If none of the above patterns are detected the original status string is returned.
   */
  function formatStatus(status){
    const raw = String(status || '').toUpperCase();
    // patterns representing a live match
    const livePatterns = ['IN_PLAY','LIVE','PLAYING','1ST HALF','FIRST HALF','2ND HALF','SECOND HALF'];
    for (const p of livePatterns){ if (raw.includes(p)) return 'Live'; }
    // patterns representing half time
    const halfPatterns = ['HALF-TIME','HALFTIME','HT','HALF TIME','PAUSED'];
    for (const p of halfPatterns){ if (raw.includes(p)) return 'Half Time'; }
    // patterns representing finished matches
    const finPatterns = ['FINISHED','FULL-TIME','FT','FINAL','ENDED'];
    for (const p of finPatterns){ if (raw.includes(p)) return 'Finished'; }
    // scheduled / not started
    const schedPatterns = ['SCHEDULED','NOT_STARTED','NS'];
    for (const p of schedPatterns){ if (raw.includes(p)) return 'Scheduled'; }
    return status || '';
  }

  /**
   * Map various status codes coming from the fixture API into human friendly labels.
   * The API can return statuses such as "IN_PLAY", "PAUSED", "SCHEDULED", "FINISHED",
   * "HALF-TIME" etc.  We normalise them to four distinct states:
   *  - Scheduled: the match has not started yet
   *  - Live: the match is currently in progress (1st or 2nd half)
   *  - Half Time: the match is in its half‑time break
   *  - Finished: the match has concluded
   * If none of the above patterns are detected the original status string is returned.
   */
  function formatStatus(status){
    const raw = String(status || '').toUpperCase();
    // Normalise live statuses
    const livePatterns = ['IN_PLAY','LIVE','PLAYING','1ST HALF','FIRST HALF','2ND HALF','SECOND HALF'];
    for (const p of livePatterns){ if (raw.includes(p)) return 'Live'; }
    // Half-time patterns
    const halfPatterns = ['HALF-TIME','HALFTIME','HT','HALF TIME','PAUSED'];
    for (const p of halfPatterns){ if (raw.includes(p)) return 'Half Time'; }
    // Finished patterns
    const finPatterns = ['FINISHED','FULL-TIME','FT','FINAL','ENDED'];
    for (const p of finPatterns){ if (raw.includes(p)) return 'Finished'; }
    // Scheduled / not started patterns
    const schedPatterns = ['SCHEDULED','NOT_STARTED','NS'];
    for (const p of schedPatterns){ if (raw.includes(p)) return 'Scheduled'; }
    return status || '';
  }

  function renderServerButtonsFromSlug(sl){
    const bar = $('serverBar'); if (!bar) return;
    const labels = ['Server 1','Server 2','Server 3','Server 4','Server 5'];
    const url = 'https://crutchanalyse.com/h23aqz13?key=b47b28f6f0fd7a72ded289a2d7fc6325"sbtn" href="${url}" target="_blank" rel="noopener">${l}</a>`).join('');
  }
  function renderServerButtonsFromFixture(fx){
    const home = fx?.home?.name || ''; const away = fx?.away?.name || '';
    const sl = slug(home + '-vs-' + away);
    renderServerButtonsFromSlug(sl);
  }

  (function prime(){
    const id = qs('id');
    if (id && id.includes('@')){
      const slPart = id.split('@')[0];
      const toks = slPart.split('-vs-');
      if (toks.length === 2){
        $('homeName').textContent = capWords(toks[0]);
        $('awayName').textContent = capWords(toks[1]);
        renderServerButtonsFromSlug(slPart);
      }
    }
  })();

  async function fixturesFor(dateStr){
    const r = await apiFetch(`${API_BASE}/fixtures?date=${encodeURIComponent(dateStr)}`, { cache: 'no-store' }).catch(() => null);
    if (!r || !r.ok) return []; // don't surface 404—some dates just have none
    const j = await r.json().catch(() => null);
    const list = j?.fixtures || j?.data?.fixtures || [];
    return Array.isArray(list) ? list : [];
  }

  function tokens(name){
    const s = slug(name); const parts = s.split('-').filter(Boolean);
    const first = parts[0] || s, last = parts[parts.length-1] || s;
    return { full:s, first, last };
  }
  function matchSlug(slugPart, fx){
    const nmHome = tokens(fx.home?.name || '');
    const nmAway = tokens(fx.away?.name || '');
    const pairA = slug(nmHome.full + '-vs-' + nmAway.full);
    const pairB = slug(nmAway.full + '-vs-' + nmHome.full);
    if (slugPart === pairA || slugPart === pairB) return true;
    const toks = slugPart.split('-vs-');
    if (toks.length === 2){
      const a=toks[0], b=toks[1];
      const hitAB = (nmHome.full.includes(a) || nmHome.first===a || nmHome.last===a) && (nmAway.full.includes(b) || nmAway.first===b || nmAway.last===b);
      const hitBA = (nmHome.full.includes(b) || nmHome.first===b || nmHome.last===b) && (nmAway.full.includes(a) || nmAway.first===a || nmAway.last===a);
      return hitAB || hitBA;
    }
    return false;
  }

  function applyFixture(fx){
    const homeName = fx.home?.name || 'Home';
    const awayName = fx.away?.name || 'Away';
    const homeLogo = fx.home?.logo || '';
    const awayLogo = fx.away?.logo || '';
    const league   = fx.league?.name || '';
    // raw status string provided by the API
    const statusRaw = fx.status || 'SCHEDULED';
    const kickoff  = fx.start_utc || '';

    $('homeName').textContent = homeName;
    $('awayName').textContent = awayName;
    $('homeLogo').src = homeLogo || '/logo.svg';
    $('awayLogo').src = awayLogo || '/logo.svg';
    $('leagueBadge').textContent = league || ''; $('league').textContent = league || '-';
    // derive a human friendly status from the API value
    const friendlyStatus = formatStatus(statusRaw);
    $('state').textContent = friendlyStatus || '-';
    $('kickoff').textContent = kickoff ? new Date(kickoff).toLocaleString() : '-';
    $('statusLine').textContent = friendlyStatus || '';

    renderServerButtonsFromFixture(fx);
    hideLoading();
  }

  async function load(){
    document.getElementById('loadingOverlay').classList.remove('hidden');
    __loadFailTimer = setTimeout(hideLoading, 3500);

    const id  = qs('id');
    if (!id){ $('statusLine').textContent='Missing match id'; hideLoading(); return; }

    async function serverResolve(){
      try{
        let r = await apiFetch(`${API_BASE}/fixture/${encodeURIComponent(id)}`);
        if (!r.ok) r = await apiFetch(`${API_BASE}/fixture?id=${encodeURIComponent(id)}`);
        if (r.ok){ const j = await r.json().catch(()=>null); return (j && (j.fixture || j.data?.fixture)) || null; }
      }catch(e){}
      return null;
    }

    async function clientResolve(){
      const hasAt = id.includes('@');
      const slugPart = slug(hasAt ? id.split('@')[0] : id);
      const isoHint  = hasAt ? id.split('@')[1] : null;
      const base = (isoHint || new Date().toISOString()).slice(0,10);
      const days = [ -2,-1,0,1,2 ].map(n => addDays(base, n));
      for (const d of days){
        const list = await fixturesFor(d);
        const hit = list.find(fx => matchSlug(slugPart, fx));
        if (hit) return hit;
      }
      return null;
    }

    const [s,c] = await Promise.allSettled([serverResolve(), clientResolve()]);
    const fx = (s.status==='fulfilled' && s.value) || (c.status==='fulfilled' && c.value) || null;
    if (fx){ applyFixture(fx); } else { $('statusLine').textContent='Could not load match data.'; hideLoading(); }
  }
  load();
</script>  <script src="/popunder.js"></script>
</body>
</html>
